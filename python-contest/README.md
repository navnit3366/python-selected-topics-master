# 保龄球 (bowling)

写一个程序来打保龄球。 输入:字符串(如下所述)表示保龄球游戏 输出:整数的分数

评分规则: 每局游戏，包括十个回合， 在每一个回合中，参与者都有两次机会把十个球瓶都打掉。

如果一个回合中，第一个球把10个球瓶都敲掉了， 这被称为“全中”。回合结束。本回合分数为10 + 接下来两球打掉的球瓶数。

如果一个回合里的第二个球把10个球瓶都打掉了， 这被称为“补全”。回合结束了。分数为框架是10 + 接下来一个球打掉的球瓶数。

如果，在两个球之后，仍然至少有一个球瓶站立， 本回合分数为两个球打掉的球瓶总数。

如果你在第10个回合打出“全中”，你就会得到2个奖励球 如果你在第10个回合打出“补全”，你就会得到1个奖励球

这些额外的奖励球被作为同一回合的一部分。 如果一个额外的球打倒了所有的球瓶，这个过程 不重复。奖励球只用于计算最后一个回合的分数。

游戏分数是所有回合分数的总和。

例子: X表示“全中” /表示“补全” :表示错过 |表示回合边界 ||后面的字符表示额外的奖励球

X|X|X|X|X|X|X|X|X|X||XX 十次“全中”在十个回合的第一个球上。 两个额外的球，都“全中”。 每一个回合的得分= = 10 + 分数球= = 10 + 10 + 10 = = 30 总得分= = 10回合 x 30 = = 300

9-|9-|9-|9-|9-|9-|9-|9-|9-|9-|| 九个球瓶在十个回合的第一个球被击中。 每一回合的第二球错过最后的球瓶。 没有额外的球。 每一回合的得分 = = 9 总分= = 10回合 x 9 = = 90

5/|5/|5/|5/|5/|5/|5/|5/|5/|5/||5 在十回合的第一个球上有五个球瓶。 每一回合的第二颗球击中剩下的5个球瓶。 一个额外的球，击中5个球瓶。 每回合的得分 = = 10 + 下一个球的分数 = = 10 + 5 = = 15 总分= = 10回合x 15 = = 150

X|7/|9-|X|-8|8/|-6|X|X|X||81 总分= = 167

输入输出文件格式：输入文件的第一行为测试数据的个数，后面每一行为一个测试数据；输出文件每一行对映一个测试数据的分数结果。

例子:

Input:

2

X|X|X|X|X|X|X|X|X|X||XX

X|7/|9-|X|-8|8/|-6|X|X|X||81

Output:

300

167

# 大数加法 (largeadd)

在计算机中，由于处理器位宽限制，只能处理有限精度的十进制整数加减法，比如在32位宽处理器计算机中，参与运算的操作数和结果必须在-2^31~2^31-1之间。如果需要进行更大范围的十进制整数加法，需要使用特殊的方式实现，比如使用字符串保存操作数和结果，采取逐位运算的方式。如下：

9876543210 + 1234567890 = ?

让字符串 num1 = "9876543210"，字符串 num2 = "1234567890"，结果保存在字符串 result = "11111111100"。

-9876543210 + (-1234567890) = ?

让字符串 num1 = "-9876543210"，字符串 num2 = "-1234567890"，结果保存在字符串 result = "-11111111100"。
要求编程实现上述高精度的十进制加法。

Input

num1, num2

num3, num4

num1,num2,num3,num4: 字符串形式操作数，如果操作数为负，则num1的前缀为符号位'-'

Output

保存加法计算结果字符串，如果结果为负，则字符串的前缀为'-'

result Of Num1 Add Num2

result Of Num3 Add Num4

注：

(1)当输入为正数时，'+'不会出现在输入字符串中；当输入为负数时，'-'会出现在输入字符串中，且一定在输入字符串最左边位置；

(2)输入字符串所有位均代表有效数字，即不存在由'0'开始的输入字符串，比如"0012", "-0012"不会出现；

(3)要求输出字符串所有位均为有效数字，结果为正或0时'+'不出现在输出字符串，结果为负时输出字符串最左边位置为'-'。

输入例子

9876543210,1234567890

输出例子

11111111100

# 龙门客栈 longmen)

明朝宪宗年间，宦官弄权，滥杀贤臣。侠客赵怀安在营救忠良行动中，将恶贯满盈的东厂督主万喻楼一剑毙命，引来西厂督主雨化田，祭出天下格杀令。
赵怀安等人一路亡命，途中布满了西厂的眼线，一旦被发现他们将面临全天下亡命之徒的围攻。 他们得知曾毁于大火的龙门客栈里，风骚的老板娘早已神秘失踪，只剩下逃过火劫的伙计们重起炉灶，痴等老板娘回来。
于是他们决定前往龙门客栈寻求帮忙。但铺天盖地的黑沙暴即将来临，好在他们得到了西厂的布防图。
但布防图太复杂，一时也判断不出是否能在规定的时间内到达龙门客栈。 关键时刻赵怀安使出了“一梦千年”的绝技，托梦给500年后的你，现在请你帮忙计算出来他们在规定的时间内能否有机会到达龙门客栈？
他会为你提供西厂的布防图以及黑沙暴到来的时间T。请你用现代科技帮忙判断是否能在规定的时间内到达龙门客栈。

Input

题目包括多组测试数据。

每组测试数据以三个整数N,M,T(0 < N,M <= 20)开头，分别代表布防图的长(N)和高(M)，以黑沙暴到来 的天数(T)。
紧接着有M行，N列字符，由”.”，”*”，”Z”，”L”组成。每行中每两个字符用空格隔开。其中:

“.” 代表能够通过的道路。

“*” 代表有西厂的眼线，赵怀安不能从此通过。

“L” 是龙六客栈所在的位置。

“Z” 是赵怀安的起始位置。

每天赵怀安只能选择上、下、左、右任意一方向走一条路。

Output

输出格式 Case #caseIndex: result

caseIndex是case序号，从 1 开始。

restult 是 "YES" 或 "NO" 如果能在规定时间内到达龙门客栈，则是”YES", 否则是”NO“

例子

Input

2

4 4 5

. . . L

. * . .

. * . .

Z . . *

3 4 5

. . L

\* . .

\* . .

Z . *

Output

Case #1: NO

Case #2: YES

# 盗墓笔记 (book)

盗墓笔记系列图书进入了英国市场, 为了刺激5本不同的盗墓笔记图书的销量，某人气书店决定在店庆活动中为盗墓笔记系列图书提供各种购买的折扣。
5本书的零售价均为8欧元，但是，

如果你购买2种不同的书，你会得到一个5%折扣；

如果你购买3种不同的书，你会得到10%的折扣；

如果你购买4种不同的书，你会得到20%的折扣；

如果你购买5种不同的书，得到一个巨大的25%折扣。

请注意，如果你买四本书，其中3本不同的标题， 对于这3本书，你会得到10%的折扣，但对于第4本书，你仍然要付8欧元。
你的任务是编写一段代码来计算的任何可能的购物篮(只包含盗墓笔记丛书)，提供尽可能大的折扣。

例如，这个篮子的书需要多少钱?

2本第一本书

2本第二本书

2本第三本书

1本第四本书

1本第五本书

组合这8本书的方法一:

1组5 本―>25%的折扣(1，2，3，4，5)+ 1组3本―>10%的折扣(1，2，3)
即：

5本书25%的折扣+ 3本书10%的折扣

即：
5 x(8 - 2.00) + 3 x(8 - 0.80) == 51.60
总共51.60

然而，组合这8本书的方法二:

1组4本―> 20%的折扣(1，2，3，4)

1组4本―> 20%的折扣(1，2，3，5)

即：
4本书20%的折扣+ 4本书20%的折扣
即：
4 x(8 - 1.60) + 4 x(8 - 1.60) == 51.20
总共51.20

最终，51.20的价格是最大的折扣。

程序的输入文件的第一行是一个整数代表用例数量, 以后各行各为一个用例. 每个用例均为一行数字, 每位代表购物篮里的一本书, 该位数字即是这本书的集号。
要求输出文件的第一行是一个整数代表用例数量, 以后各行各为一个用例的最优价格。
测试用例数量<=1000, 每个测试用例中书的本数<=1000。

例如, 输入文件:

1

1233

相应的输出文件:

1

29.6

# 幼儿园分糖果 (candy)

你是一位聪明的幼儿园老师，今天是幼儿园开放日。大批家长，记者们凭借收到的邀请会准备一组接一组前来参观幼儿园。幼儿园为来参观的每个人都准备了可口的糖果，一人一颗。 糖果是盒装的，每盒的颗数P都相同。环保又小气的园长告诉你尽量不要浪费这些糖果，在分完一盒糖果之前绝对不要拆开新的一盒！但是作为家长或者记者，分到一颗从别的小组分剩下的糖果是一件不怎么高兴的事情。比如一盒糖果是3颗，第一组参观的人数是5人，那就会拆出两盒糖果，在一人分到一颗之后剩下了一颗。这样第二组参观的某人就分到了那颗剩下的，心想你们怎么这么抠门。作为组织老师的你两头受气，既不能违反园长的嘱咐又希望能改善这次参观体验。于是你从园长那里得到了准备参观幼儿园的人员分组情况。你不能改变每组的人数，你也不能拒绝某一组的参观，你还要保证每个人都分到一颗糖，你能做的就是合理安排各组参观幼儿园的顺序来让尽可能多的小组里的所有人都分到新拆开的糖果。

举个完整的例子
假如有4组人员准备前来参观，分别是5人，6人，4人，4人。糖果一盒是3颗。如果你按照5，6，4，4的顺序安排他们参观，那第一组的所有人都很开心的分到了新开的糖果，第二组某人分到了第一组剩下的一颗而不太开心，第三组又有某人分到了第二组剩下的一颗也不怎么高兴。第四组的所有人又都分到了新开的糖果觉得不错。4组参观下来有2组非常满意而另外两组颇有微词。如果你灵机一动，把他们的参观顺序改成4，5，6，4，这样我们会发现除了第二组，其他三组都会分到全新拆开的糖果而感到非常满意。这也是能取得的最好结果了。

输入（Input）

文件的第一行是测试用例的个数T。接下来会有T个case。每个case有2行，第一行有两个数字，第一个是参观的小组个数N，第二个数是每盒糖果的颗数P。第二行会有N个数字，G1, G2, ..., GN分别表示每个参观小组的人数。

输出（Output）

对于每个测试用例，在输出文件中输出一行包含 Case #x: y的样式。其中x是测试用例的编号（从1开始），y是这个测试用例中最大有可能达到的让所有人分到新拆开糖果而感到满意的小组个数。
限制（Limits）

1 ≤ T ≤ 100.

1 ≤ N ≤ 100.

1 ≤ Gi ≤ 100, for all i.

Small dataset

2 ≤ P ≤ 3.

Large dataset

2 ≤ P ≤ 4.

例子

Input

3

4 3

4 5 6 4

4 2

4 5 6 4

3 3

1 1 1

Output

Case #1: 3

Case #2: 4

Case #3: 1
